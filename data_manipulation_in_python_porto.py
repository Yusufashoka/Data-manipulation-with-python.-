# -*- coding: utf-8 -*-
"""Data Manipulation in Python Porto

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1E2UNBWSx2wBfY_z3h4upAAOAoyBr4R4K

# DATA MANIPULATION WITH PYTHON

Data manipulation means to organize or arrange the kind of structured data that is read by computer programs so that itâ€™s easier to interpret. Performing this process effectively can improve the quality of your data and analysis.
"""

#Importing the library
import pandas as pd
import numpy as np

"""Pandas has two objects, namely series and data frames.

# Object Series
Series is a one-dimensional labeled array capable of holding any data type (integers, strings, floating point numbers, Python objects, etc.). The axis labels are collectively referred to as the index. Pandas Series is nothing but a column in an excel sheet. Labels need not be unique but must be a hashable type.

Pandas Series will be created by loading the datasets from existing storage, storage can be SQL Database, CSV file, and Excel file. Pandas Series can be created from the lists, dictionary, and from a scalar value etc.

- Creating a series from array
"""

data = np.array(['c','o','m','m','e','n','t'])  #use array() function
 
series = pd.Series(data)
print(series)

"""- Accessing element of Series

There are two ways through which we can access element of series, they are :

- Accessing Element from Series with Position
- Accessing Element Using Label (index)
"""

#Accessing Element from Series with Position
# creating simple array
data = np.array(['m','y','e','d','u','s','o','l','v','e'])
series = pd.Series(data)
  
  
#retrieve the first element
print(series[:5])

#Accessing Element Using Label (index)
# accessing a element using index element
# creating simple array
data = np.array(['m','y','e','d','u','s','o','l','v','e'])
series = pd.Series(data,index=[11,12,13,14,15,16,17,18,19,20]) 
# accessing a element using index element
print(series[20])

print(series)

data = [0.3, 0.45, 0.6, 0.75, 0.9]

"""Change the Data into Series"""

data = pd.Series(data)
print(data)

"""Convert Series into Array"""

data.values

print(data[:3])

"""display index.
The index is a range, where the starting point is inclusive of the range and the stop point is exclusive to the range.
"""

data.index

list(range(1,10))

"""How to call data"""

data

data[2]

"""implicit index is the default index
we can define the index, this is called the explicit index that is defined.
when defining an index, the number of indexes must be equal to the number of data.
"""

data = [0.3, 0.45, 0.6, 0.75, 0.9]
data = pd.Series(data, index =['a','b','c','d','e'])
print(data)

data

data.values

"""Call the data"""

#explicit index

data['a']

"""this is data selection


even though we have created an explicit index, we can still call the implicit index
"""

#indeks implisit

data[3]

"""when the implicit index and the explicit index are the same. when we call the data, it will only call the explicit index"""

data_2 = pd.Series([0.25, 0.50, 0.75, 1], index=[2,5,3,7])

data_2

data_2[2]

data_2[0]

"""We will try to do data slicing"""

data = pd.Series([0.25, 0.50, 0.75, 1], index=['a','b','c','d'])

data

"""for example we will call from data b to data c"""

data['b':'c'] #explicit index

"""but we can slice with the implicit index, then only the starting point will appear. because the implicit index is a range"""

data[1:2] #implicit index

"""# Loc dan iLoc

Example of data that has the same implicit index and explicit index
"""

data_2 = pd.Series([0.25, 0.50, 0.75, 1], index=[2,5,3,7])

data_2

"""when we access one index then what appears is the explicit index"""

data_2[2] #indeks eksplisit : selecting

"""when we call the explicit index from index 2 to index 3. the value that appears is precisely the implicit index"""

data_2[2:3] #indeks implisit : slicing

"""ketika indeks eksplisit dan indeks implisit ada yang sama maka akan terjadi inkonsistensi seperti case di atas

untuk mengatasi keadaan inkonsistensi tersebut maka kita akan gunakan kaidah Loc dan iLoc 

Loc adalah untuk memanggil indeks eksplisit nya
iLoc adalah untuk memanggil indeks implisit nya
"""

#loc

data_2.loc[3] #selecting indeks eksplisit

data_2.loc[2:3] #slicing indeks eksplisit

#iloc

data_2.iloc[3] #selecting indekx implisit

#iloc
#slicing indeks implisit

data_2.iloc[2:3]

"""# Data Frame

Data Frame is a collection of series, with at least one series
"""

dict_population = {'Jakarta':750,
                 'Bogor':400,
                 'Depok':350,
                 'Tanggerang':270,
                 'Bekasi':670}

#just example

dict_population

#transform dictionary into series
population = pd.Series(dict_population)

population

population.loc['Depok']

population.iloc[2]

dict_large = {'Jakarta':750,
                 'Bogor':400,
                 'Depok':350,
                 'Tanggerang':270,
                 'Bekasi':670}

#just example

large = pd.Series(dict_large)

large

area = pd.DataFrame({'pop':population, 'large':large})

area

area['large']['Jakarta']

"""when calling data with the regional.pop syntax it will appear as below because pop is the same as the name of the function in the Data Frame"""

area.pop

"""then it is safer to call the data with the syntax area['population']"""

area['pop']

"""we rename the column pop to population"""

area = pd.DataFrame({'population':population, 'large':large})

area

"""In the population area, take data that has been done by the previous data frame"""

area['population']

"""# Next it does with an explicit index on its population syntax"""

area['population']['Jakarta':'Depok'] #index explicit

area['population'].iloc[0:3] #index implicit

#add new Colom
area['pop_per_area']=area['population']/area['large']

area

#add new line
area_addition=pd.DataFrame({"Bandung":[151, 148, 0.18]})

area_addition

area_addition=area_addition.T

area_addition

area_addition.columns=area.columns

area_addition

#combine regional data and additional_area data with concat

pd.concat([area, area_addition])

#deleting the column is not permanent, meaning that it is still stored in the data source